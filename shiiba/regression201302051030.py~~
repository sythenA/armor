# advection/shiiba.py
# to calculate the advection coefficiations after Shi-iba et al
# Takasao T. and Shiiba M. 1984:  Development of techniques for on-line forecasting of rainfall and flood runoff (Natural Disaster Science 6, 83)
# with upwind scheme etc
#
# use:  1) python shiiba.py      
#  or   2) import advection.shiiba
#

# plan for 3-1-2012:
# 
# A. write the functions
#   0. basic I/O (input/output/display;  use/enhance basics.py)
#   1. central difference scheme
#   2. upwind scheme
# B. write some test codes
#   1. get the dbz images
#   2. do the regression
#   3. see/plot the output vector field
# C. (if there's time)  do the advection - use another module
 

# overall plan for the future:
# multilevel shiiba regression, or local regression with pre-defined segmentation 
#   (e.g. from k-means, or another shiiba regression, or thresholding, etc)

#   imports

import numpy as np
import numpy.ma as ma
from .. import pattern
import copy
################################################################
#   the functions

def centralDifference(phi0, phi1):

    """
    adapted from shiiba.py, internalising the parameters into the objects
    dt, dx, dy comes from the latter dbz image phi1
    25 January 2013, Yau Kwan Kiu.
        ----
    to compute the advection coefficients via the central difference scheme
    as a step to the shiiba method
    use numpy.linalg.lstsq for linear regression:  
        http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.lstsq.html

    We shall use the C/python convention for coordinate axes, but with the first axis going up,
    following the convention of the Central Weather Bureau and matplotlib (meshgrid) usage

    first axis
    ^
    |
    |
    + ----> second axis

    input:  phi0,phi1   - two armor.pattern.DBZ objects (wrapping a masked array)
    output: v           - an armor.pattern.VectorField object (wrapping a pair of masked arrays)
 
    
    """
    # setting up the parameters

    dt = phi1.dt    # use the attribute of the latter DBZ image
    dj = phi1.dx
    di = phi1.dy

    ####################################################
    # defining the shifted masked arrays  
    #                              [ref: http://docs.scipy.org/doc/numpy/reference/maskedarray.generic.html 
    #                                   http://docs.scipy.org/doc/numpy/reference/routines.ma.html      ]
    ########    initialise
    #   phi0_up.matrix     = np.roll(phi0.matrix,+1,axis=0)   
    #   phi0_down.matrix   = np.roll(phi0.matrix,-1,axis=0)
    #   phi0_left.matrix   = np.roll(phi0.matrix,-1,axis=1)
    #   phi0_right.matrix  = np.roll(phi0.matrix,+1,axis=1)
    ########    to set the masks
    #   phi0_up.mask[ 0,:]  = 1      #mask the first (=bottom) row
    #   phi0_down.mask[-1,:]= 1      #mask the last (=top) row
    #   phi0_left.mask[:,-1]= 1      #mask the last (=right) column
    #   phi0_right.mask[:,0]= 1      #mask the first (=left) column


    phi0_up     = phi0.shiftMatrix( 1, 0)   # a new armor.pattern.DBZ object defined via DBZ's own methods
    phi0_down   = phi0.shiftMatrix(-1, 0)          
    phi0_left   = phi0.shiftMatrix( 0,-1)
    phi0_right  = phi0.shiftMatrix( 0, 1)

    ##############################################

    # applying the advection equation
    # see ARMOR annual report (1/3), section 4.2.1, esp. eqn (4.3)

    Y = (phi1.matrix-phi0.matrix)                   # regression:  Y = X.c, where c = (c1,...,c6) 
                                                    # (up to signs or permutations) are the unknowns
    if phi1.verbose or phi0.verbose:
        print 'sum(sum(Y.mask))=', sum(sum(Y.mask))
    X = np.zeros((phi0.matrix.shape[0], phi0.matrix.shape[1], 6))     # a 2x3 matrix for each pixel 
                                                        # -> 6 vector for (c1,c2,c3,c4,c5,c6)
                                                        # where u=c1x+c2y+c3, v=c4x+c5y+c6, j=x, i=y, 
                                                        # therefore up to +- signs or permutations, 
                                                        # X=(A1c1, A1c2, A1c3, A2c1, A2c2, A2c3)

    # Central difference scheme: phi(i+1)-phi(i-1) / 2di, etc
    if phi1.verbose or phi0.verbose:
        print "phi0,1.matrix.shape", phi0.matrix.shape, phi1.matrix.shape #debug
    A = ma.array([-dt*(phi0_down.matrix - phi0_up.matrix)   /(2*di),\
                  -dt*(phi0_left.matrix - phi0_right.matrix)/(2*dj)])  
    A = np.transpose(A, (1,2,0))                #swap the axes:  pixel dim1, pixel dim2, internal
    Bj, Bi = np.meshgrid( range(phi0.matrix.shape[1]), range(phi0.matrix.shape[0]) )       #location stuff, from the bottom left corner

                                #############################
                                #  IS THE ABOVE CORRECT???  #
                                # or should that be something like
                                # meshgrid(phi0.matrix.shape[1], phi0.matrix.shape[0]
                                # and we have transpose (1,2,0) below?
                                #############################                                

    B = ma.array([Bi,Bj]).transpose((1,2,0))                                          # (881x921x2), (i,j, (i,j) )
    
    #[a,b] * [[x,y],[z,w]] * [c,d].T = [acx+ady+bcz+bdw];  want:  [ac, ad, bc, bd]
    # debug
    if phi0.verbose or phi1.verbose:
        print '== shapes for X, A and B: =='
        print X.shape, A.shape, B.shape
    X[:,:,0] = A[:,:,0]*B[:,:,0]        # coeffs for c1,..,c6 up to a permutation i,j=y,x 
                                        # which we don't care for now
    X[:,:,1] = A[:,:,0]*B[:,:,1]       
    X[:,:,2] = A[:,:,0]                 # the constant term
    X[:,:,3] = A[:,:,1]*B[:,:,0]       
    X[:,:,4] = A[:,:,1]*B[:,:,1]        
    X[:,:,5] = A[:,:,1]

    if phi0.verbose or phi1.verbose:
        # debug
        print "X.max, X.sum() = "
        print X.max(), X.sum()
    
        print "A.max, A.sum() = "
        print A.max(), A.sum()
        print "B.max, B.sum() = "
        print B.max(), B.sum()

        print Y.shape

    Y = Y.reshape(phi0.matrix.size,1)        # convert the pixel data into a column vector    
    X = X.reshape(phi0.matrix.size,6)

    # HACK FOR numpy problem:  dealing with numpy.linalg.lstsq which sees not the mask for masked arrays
    Y1 = ma.array(Y.view(np.ndarray)*(Y.mask==0))
    X1 = ma.array(X.view(np.ndarray)*(Y.mask==0))                #yes, that's right.  X* (Y.mask==0)d
    Y1.mask = Y.mask

    C, residues, rank, s = np.linalg.lstsq(X1,Y1)
    c1,c2,c3,c4,c5,c6 = C
    
    SStotal = ((Y1-Y1.mean())**2).sum()   # total sum of squares 
                                        # http://en.wikipedia.org/wiki/Coefficient_of_determination
                                        # array operations respect masks
    # !!!! debug !!!!
    # print "SStotal=", SStotal
    # print "sum of residues=",residues[0]
    #
    #print C.shape, X1.shape, Y1.shape
    #print [v[0] for v in C]
    #C = np.array([v[0] for v in C])
    #residue2 = ((C * X1).sum(axis=1) - Y1)**2
    #
    #print "((C * X1).sum(axis=1) - Y1)**2 = ", residue2
    #print "difference:", residue-residue2
    print (1-Y.mask).sum(), ((Y-Y.mean())**2).sum(), ((Y1-Y1.mean())**2).sum(), residues

    R_squared = 1 - (residues[0]/SStotal)
    print "R_squared=", R_squared
    return ([c1[0],c2[0],c3[0],c4[0],c5[0],c6[0]], R_squared)

###################################################################################################

def upWind(phi0, phi1, convergenceMark = 0.000001):
    """ adapted to object oriented form 27-1-2013
    -----
    to compute the advection coefficients via the central difference scheme
    as a step to the shiiba method
    u(k-1) and v(k-1) are given, possibly, from previous upWind steps
    or from the central differnece scheme
    builds upon the central difference scheme
    11-1-2013
    """
    # algorithm:  1. start with the central difference scheme to obtain an initial (u0,v0)
    # 2. recursively regress for the next u(n+1), v(n+1) until convergence
    #to get the shifted arrays - copied from def centralDifference
    ###########
    dt = phi1.dt    # use the attribute of the latter DBZ image
    dj = phi1.dx
    di = phi1.dy
    verbose = phi0.verbose or phi1.verbose
    if verbose:
        print '==========================================================================='
        print 'di, dj, dt, convergenceMark =', di, dj, dt, convergenceMark
    phi0_up     = phi0.shiftMatrix( 1, 0)   # a new armor.pattern.DBZ object defined via DBZ's own methods
    phi0_down   = phi0.shiftMatrix(-1, 0)          
    phi0_left   = phi0.shiftMatrix( 0,-1)
    phi0_right  = phi0.shiftMatrix( 0, 1)

    [c1_, c2_, c3_, c4_, c5_, c6_ ], R_squared_ = centralDifference(phi0=phi0, phi1=phi1)

    if verbose:
        vect        = getShiibaVectorField((c1_, c2_, c3_, c4_, c5_, c6_ ),phi1)
        vect.show()

    J,I = np.meshgrid(np.arange(0,phi0.matrix.shape[1]), np.arange(0,phi0.matrix.shape[0]))
    # see our ARMOR December 2012 annual report (1/3), section 4.2.1, esp. eqn (4.3)
    c1 = 9999; c2 = 9999 ;  c3=-9999 ; c4=9999 ; c5=-9999 ; c6= -9999   #initialise
    # perhaps I should change the following convergence criterion
    # from absolute value to component-wise-scaled correlations 
    while (c1_-c1)**2 + (c2_-c2)**2 + (c3_-c3)**2 + (c4_-c4)**2 + (c5_-c5)**2 + \
                (c6_-c6)**2 > convergenceMark:
        c1_=c1; c2_= c2; c3_=c3; c4_=c4; c5_=c5; c6_=c6
        #debug
        #print "        print U0.shape, V0.shape, phi0.shape,  \nprint di.shape, dj.shape "
        #print U0.shape, V0.shape, phi0.shape, 
        #print di.shape, dj.shape
        U0  = c1_*I + c2_*J + c3_   # use old (c1,..c6) to compute old U,V
        V0  = c4_*I + c5_*J + c6_   # to be used as estimates for the new U,V
        upWindCorrectionTerm = abs(U0/(2*di)) * (2*phi0.matrix -phi0_down.matrix -phi0_up.matrix)  +\
                               abs(V0/(2*dj)) * (2*phi0.matrix -phi0_left.matrix -phi0_right.matrix)
        upWindCorrectionTerm = pattern.DBZ(dataTime=phi1.dataTime, matrix=upWindCorrectionTerm)

        # the following line doesn't work: takes up too much computation resource
        #upWindCorrectionTerm = abs(U0/(2*di)) * (2*phi0 -phi0_down -phi0_up)  +\
        #                       abs(V0/(2*dj)) * (2*phi0 -phi0_left -phi0_right)

        #print 'sum(upWindCorrectionTerm.mask==0)=',sum( (upWindCorrectionTerm.mask==0)) #debug
        [c1, c2, c3, c4, c5, c6], R_squared = centralDifference(phi0=phi0 + dt *upWindCorrectionTerm,\
                                                              phi1=phi1) 
        if verbose: 
            print "\n##################################################################\n"
            print "c1, c2, c3, c4, c5, c6: ",  c1, c2, c3, c4, c5, c6
            print "\nR^2: ", R_squared
            print "\n##################################################################\n"
    return [c1, c2, c3, c4, c5, c6], R_squared

def shiiba(phi0, phi1, convergenceMark = 0.00001):
    ### a pointer for the moment
    ###
    return upWind(phi0, phi1, convergenceMark = 0.00001)

def getShiibaVectorField(shiibaCoeffs, phi1, gridSize=25, name="",\
                     key="Shiiba vector field", title="UpWind Scheme"):
 
    """ plotting vector fields from shiiba coeffs
    input:  shiiba coeffs (c1,c2,c3,..,c6) for Ui=c1.I + c2.J +c3, Vj=c4.I +c5.J+c6
    and transform it via I=y, J=x, to Ux = c5.x+c4.y+c6, Vy = c2.x+c1.y+c3
    """
    # 1. setting the variables
    # 2. setting the stage
    # 3. plotting
    # 4. no need to save or print to screen

    # 1. setting the variables
    c1, c2, c3, c4, c5, c6 = shiibaCoeffs
    c5, c4, c6, c2, c1, c3 = c1, c2, c3, c4, c5, c6     # x,y <- j, i switch
    # 2. setting the stage
    height= phi1.matrix.shape[0]
    width = phi1.matrix.shape[1]
    mask  = phi1.matrix.mask
    name  = "shiiba vector field for "+ phi1.name
    imagePath = phi1.name+"shiibaVectorField.png"
    key   = key
    ploTitle  = title
    gridSize = gridSize
    X, Y    = np.meshgrid(range(width), range(height))
    Ux      = c1*X + c2*Y + c3
    Vy      = c4*X + c5*Y + c6
    Ux      = ma.array(Ux, mask=mask)
    Vy      = ma.array(Vy, mask=mask)
    #constructing the vector field object
    vect    = pattern.VectorField(Ux, Vy, name=name, imagePath=imagePath, key=key,
                                    title=title, gridSize=gridSize)
    return vect

def showshiibaVectorField(phi0,phi1):
    shiibaCoeffs= upWind(phi0,phi1)
    vect        = getShiibaVectorField(shiibaCoeffs)
    vect.show()

def shiibaNonCFL(phi0, phi1, mask=None, windowHeight=5, windowWidth=5,\
                 convergenceMark=0.0000001,):
    """ to find the shiiba coeffs without the CFL condition
    plan:
    to shift and regress, minimising the average R^2     
    """ 
    #parameters
    verbose = phi0.verbose or phi1.verbose

    #0. initialise a matrix for the r^2
    #1. put the mask on phi0
    #2. roll back phi1 by (m,n);  per our convention, internal stuff we use (i,j), not (x,y); i=y, j=x

    R2s     = {}    #dict to record the R^2s
    ShiibaCoeffs = {}    #dict to record the shiiba coeffs
    phi0.matrix.mask = mask        # put the mask on phi0

    for m in range(-(windowHeight-1)/2, (windowHeight+1)/2):
        for n in range(-(windowWidth-1)/2, (windowWidth+1)/2):
            phi1_temp = phi1.shiftMatrix(m,n)
            [c1, c2, c3, c4, c5, c6], res = upWind(phi0=phi0, phi1=phi1_temp)
            R2s    [(m,n)] = res
            ShiibaCoeffs[(m,n)] = [c1, c2, c3, c4, c5, c6]
        if verbose:
            print "\n-----------------------------\n(m,n), [c1,c2,c3,c4,c5,c6], res = \n",\
                                                (m,n), [c1,c2,c3,c4,c5,c6], res

    #getting the (m,n) for max(res)
    (m, n) = max(R2s, key=R2s.get)
    if verbose:
        print "\nfor the given mask, \nMin R2:----------------------------\n",\
                "(m,n), [c1,c2,c3,c4,c5,c6], res = \n", (m,n), [c1,c2,c3,c4,c5,c6], res

    return (m,n), ShiibaCoeffs[(m,n)], R2s[(m,n)]



def interpolation():
    """to interpolate after movements (translation, advection, rotation, etc)
    estimate phi1^(x,y) = sum_{s=x-1,x,x+1; t=y-1,y,y+1} H(s-x_pullback)*H(t-y_pullback)*phi0(s,t)
                        where H = weight function: H(x)=x cut-off and levelled at two ends 0,1 
                              _
                        H = _/

    """
    pass

def semiLagrangeAdvect():
    """to compute the semi-Lagrangian advection of a grid, given a velocity field
    """
    pass



















